In the end, it was harder to reason about everything going on. Debugging FRP processes was stepping through a lot of the internals of the libraries to find where events got twisted. Using FRP in smaller more isolated uses and limiting combining streams was much more beneficial and the file size increase if you’re just using it in place of a single callback function is not very useful. FRP hits the middle ground between these very well for me.
A simpler async and data flow
So looking around and talking to friends I looked into Go lang. It has been getting a lot of press lately for good concurrency, parallelism with and without threads (for good reason). They use a pattern called CSP. You create a channel object that lets data move across it. This is very similar to FRP. Then when you want to push data on the channel or take data out, you just tell it to set the data to a variable and “park” until that data is set. So code that looks like normal is synchronous and walks line by line acutally parks and waits until something comes across the channel before going to the next line. JavaScript will be getting this with `await` in ES2016.